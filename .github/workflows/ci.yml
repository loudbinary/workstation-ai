name: CI

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_plan:
        description: Build plan style
        required: true
        default: kubernetes
        type: choice
        options:
          - kubernetes
          - github-platform
      environment:
        description: Target environment
        required: true
        default: dev
        type: choice
        options:
          - dev
          - test
          - stage
          - prod
      deploy_kubernetes:
        description: Deploy to Kubernetes
        required: true
        default: true
        type: boolean
      deploy_codespaces:
        description: Deploy to GitHub Codespaces target
        required: true
        default: false
        type: boolean
      deploy_spark:
        description: Deploy to GitHub Spark target
        required: true
        default: false
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  app-change-issue-gate:
    name: App Changes Require Issue
    runs-on: ubuntu-latest

    steps:
      - name: Validate issue reference for app changes
        if: github.event_name == 'pull_request'
        id: appissue
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = pr.number;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: issue_number,
              per_page: 100
            });

            const hasAppChanges = files.some(file => file.filename.startsWith('apps/'));
            core.setOutput('has_app_changes', hasAppChanges ? 'true' : 'false');

            if (!hasAppChanges) {
              core.info('No app changes detected under apps/. Issue reference is not required.');
              core.setOutput('has_issue_reference', 'true');
              return;
            }

            const title = pr.title || '';
            const body = pr.body || '';
            const combined = `${title}\n${body}`;
            const hasIssueReference = /(close[sd]?|fix(e[sd])?|resolve[sd]?)\s+#\d+|#\d+|https:\/\/github\.com\/[^/]+\/[^/]+\/issues\/\d+/i.test(combined);

            core.setOutput('has_issue_reference', hasIssueReference ? 'true' : 'false');

            if (!hasIssueReference) {
              core.setFailed('App changes detected in apps/, but the PR does not reference a GitHub issue. Add a reference like "Closes #123".');
            }

      - name: Comment on PR when issue reference is missing
        if: failure() && steps.appissue.outputs.has_app_changes == 'true' && steps.appissue.outputs.has_issue_reference == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- app-change-issue-gate -->';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;

            const body = `${marker}
            ❌ This PR changes files under \`apps/\` and must reference a GitHub issue.

            Add an issue reference in the PR title or body, for example:
            - \`Closes #123\`
            - \`Fixes #123\`
            - \`https://github.com/${owner}/${repo}/issues/123\``;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const existing = comments.find(comment =>
              comment.user?.type === 'Bot' && comment.body?.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body
              });
            }

  terraform-fmt:
    name: Terraform Fmt Check
    runs-on: ubuntu-latest
    needs: app-change-issue-gate

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform fmt check
        id: fmtcheck
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .ci
          terraform fmt -check -recursive -diff infra/terraform > .ci/terraform-fmt.diff 2>&1

      - name: Comment on PR when fmt fails
        if: github.event_name == 'pull_request' && steps.fmtcheck.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- terraform-fmt-check -->';
            let diff = '';

            try {
              diff = fs.readFileSync('.ci/terraform-fmt.diff', 'utf8');
            } catch {
              diff = 'terraform fmt check failed but no diff output was captured.';
            }

            if (!diff.trim()) {
              diff = 'terraform fmt check failed but no diff output was captured.';
            }

            const maxChars = 60000;
            if (diff.length > maxChars) {
              diff = `${diff.slice(0, maxChars)}\n...output truncated...`;
            }

            const body = `${marker}
            ❌ Terraform formatting check failed.

            Run this command locally:
            \\`\\`\\`bash
            terraform fmt -recursive infra/terraform
            \\`\\`\\`

            <details><summary>terraform fmt output</summary>

            \\`\\`\\`diff
            ${diff}
            \\`\\`\\`

            </details>`;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const existing = comments.find(comment =>
              comment.user?.type === 'Bot' && comment.body?.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body
              });
            }

      - name: Fail workflow if fmt check failed
        if: steps.fmtcheck.outcome == 'failure'
        shell: bash
        run: |
          echo "Terraform formatting is not clean. Run: terraform fmt -recursive infra/terraform"
          exit 1

  build-kubernetes:
    name: Build Plan - Kubernetes
    runs-on: ubuntu-latest
    needs: terraform-fmt
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_plan == 'kubernetes'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Kubernetes plan artifacts
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/deploy/kubernetes.sh
          TARGET_ENV="${{ github.event.inputs.environment || 'dev' }}" DRY_RUN=true scripts/deploy/kubernetes.sh

  deploy-kubernetes:
    name: Deploy - Kubernetes
    runs-on: ubuntu-latest
    needs: build-kubernetes
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_plan == 'kubernetes' && github.event.inputs.deploy_kubernetes == 'true'
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to Kubernetes
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/deploy/kubernetes.sh
          TARGET_ENV="${{ github.event.inputs.environment }}" DRY_RUN=false scripts/deploy/kubernetes.sh

  build-github-platform:
    name: Build Plan - GitHub Platform
    runs-on: ubuntu-latest
    needs: terraform-fmt
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_plan == 'github-platform'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build GitHub platform artifacts
        shell: bash
        run: |
          set -euo pipefail
          echo "Preparing build artifacts for GitHub Codespaces and GitHub Spark targets"

  deploy-codespaces:
    name: Deploy - GitHub Codespaces
    runs-on: ubuntu-latest
    needs: build-github-platform
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_plan == 'github-platform' && github.event.inputs.deploy_codespaces == 'true'
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to GitHub Codespaces target
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/deploy/codespaces.sh
          TARGET_ENV="${{ github.event.inputs.environment }}" scripts/deploy/codespaces.sh

  deploy-spark:
    name: Deploy - GitHub Spark
    runs-on: ubuntu-latest
    needs: build-github-platform
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_plan == 'github-platform' && github.event.inputs.deploy_spark == 'true'
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to GitHub Spark target
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/deploy/spark.sh
          TARGET_ENV="${{ github.event.inputs.environment }}" scripts/deploy/spark.sh
